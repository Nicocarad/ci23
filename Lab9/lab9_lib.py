# Copyright Â© 2023 Giovanni Squillero <giovanni.squillero@polito.it>
# https://github.com/squillero/computational-intelligence
# Free for personal or classroom use; see 'LICENSE.md' for details.

from abc import abstractmethod


# Define an AbstractProblem class as a base for specific problem instances.
class AbstractProblem:
    # Constructor initializing call counter to 0.
    def __init__(self):
        self._calls = 0

    @property
    @abstractmethod
    def x(self):
        # Abstract property that should be implemented by subclasses to return some value.
        pass

    @property
    def calls(self):
        # Public property to get the number of fitness function calls made.
        return self._calls

    @staticmethod
    def onemax(genome):
        # Static method to calculate the 'one max' fitness, which is the sum of all '1' bits in the genome.
        return sum(bool(g) for g in genome)

    def __call__(self, genome):
        # Method that allows the instance of this class to be called as a function.
        # Increments the call counter each time it is called.
        self._calls += 1
        # Calculate the fitness for all possible substrings generated by slicing the genome with step size 'x';
        # sort the fitnesses in descending order.
        fitnesses = sorted((AbstractProblem.onemax(genome[s :: self.x]) for s in range(self.x)), reverse=True)
        
        # Calculate the total fitness as the sum of highest repeating fitness values,
        # minus a penalty for lower fitness values based on their rank (k).
        val = sum(f for f in fitnesses if f == fitnesses[0]) - sum(
            f * (0.1 ** (k + 1)) for k, f in enumerate(f for f in fitnesses if f < fitnesses[0])
        )
        # Normalize the fitness score by dividing by the length of the genome.
        return val / len(genome)


# Factory function to generate a Problem class with a specific 'x' value set via closure.
def make_problem(a):
    # Define a Problem class inheriting from AbstractProblem and implementing the 'x' property.
    class Problem(AbstractProblem):
        @property
        def x(self):
            # The 'x' property value is set to the parameter provided when calling 'make_problem'.
            # This closure ensures that 'x' has a fixed value for any instance of Problem.
            return a

    # Return the new Problem class (not an instance).
    return Problem()

